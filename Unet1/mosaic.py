"""  
A collection of tools to tile images for the use with a fully convolutional network.
Linus Meienberg
June 2020
"""

#%% Imports 
import PIL
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf 

#%% Define a tool for visual control of tiling patterns

def showTiling(image, bounding_boxes):
    """Draw an image and visualize a collection of bounding boxes

    Parameters
    ----------
    image : image tensor
        The image to show as a background for the tiling layout
    bounding_boxes : list
        a list of bounding boxes specified as 4-tuples (x,y,w,h) in image coordinates where x,y denote the coordinates of the top left corner and w,h the width and height of the bounding box
    """
    plt.figure(figsize=(10,10))
    plt.imshow(image, origin='upper')
    rectangles = []
    for box in bounding_boxes:
        box = image_to_plot(box) # transform to plot coordinates
        rect = plt.Rectangle(box[0:2], box[2], box[3], fill=False)
        plt.gca().add_patch(rect)
    
    plt.show()

def rectangularTiling(image_shape, rectangle):
    """
    Completely covers a target image with a rectangular tile

    Parameters
    ----------
    image_shape : tuple
        the dimensions of the image that should be tiled
    rectangle : tuple
        the dimensions of the rectangular tile (x,y)

    Returns
    -------
    list
        list of bounding boxes specified as 4-tuples (x,y,w,h)
    """
    rows = np.ceil(image_shape[0]/rectangle[0]).astype(int)
    cols = np.ceil(image_shape[1]/rectangle[1]).astype(int)
    #print('rows {} cols {}'.format(rows,cols))
    boxes = []
    for r in range(rows):
        # y coordinate of top left corner
        x = r * rectangle[0]
        for c in range(cols):
            # x coordinate of top left corner
            y = c * rectangle[1]
            # Add bounding box to collection of tiles
            bb = (x,y,rectangle[0],rectangle[1]) # (x,y,w,h) in image coordinates
            boxes.append( bb ) #(x,y,w,h)
    
    return boxes

#%%
def image_to_plot(bounding_box):
    """
    Converts a bounding box in the image coordinate system to an annotation in plt.imshow()

    Parameters
    ----------
    bounding_box : tuple
        bounding box in 4-tuple format in image coordinate system. (origin top left on screen. X points down Y points right)
    """
    (x_img, y_img, w_img, h_img) = bounding_box # Image coord system
    return (y_img, x_img, h_img, w_img) # Plot coord system (x,y,w,h)


# %%    
def tileUnet(image_shape, input_shape, output_shape):
    """
    Tiles an image with the output shape of the Unet. 
    For each output region the corresponding input region is calculated.
    It is assumed that the output region is centered within the input region with the same number of bordering pixels on opposing sides.

  Parameters
    ----------
    image_shape : tuple
        dimension of the target image 
    input_shape : tuple
        dimension of the input region evaluated by the unet
    output_shape : tuple
        dimension of the output region / mask generated by the unet

    Returns
    -------
    dict
        holds two list of bounding boxes in 4-tuple format (x,y,w,h)
        offset (x,y) offset of output to input region 
    """
    # Step 1 Tile the image with the output region of the unet
    output_boxes = rectangularTiling(image_shape, output_shape)
    # Step 2 Regions are assumed to be centered. Use difference to calculate input regions
    assert (input_shape[0]-output_shape[0])%2==0, 'Cannot center input in x direction'
    assert (input_shape[1]-output_shape[1])%2==0, 'Cannot center input in y direction'
    delta_x = (input_shape[0]-output_shape[0])//2
    delta_y = (input_shape[1]-output_shape[1])//2

    input_boxes = []
    for bb_out in output_boxes:
        x,y,w,h = bb_out # unpack 4 tuple
        # compute and append input region
        #NOTE coordinates outside image region will occur
        input_boxes.append((x-delta_x,y-delta_y,w+2*delta_x,h+2*delta_y))
    
    return {'input_boxes': input_boxes, 'output_boxes': output_boxes, 'offset': (delta_x,delta_y)}

 # %%
def bb_lies_in_image_region(image_shape, boundingBox):
    """Checks if a bounding box lies completely within an image

    Parameters
    ----------
    image_shape : tuple
        dimensions of the image
    boundingBox : tuple
        4-tuple (x,y,w,h) bounding box in image cordinates

    Returns
    -------
    bool
        whether the boundingBox lies completely within the image region
    """
    # The image has it's top left corner at (0,0) there can be no negative coordinates
    (x,y,w,h) = boundingBox
    valid = (x>=0 and y>=0)
    # The bounding box may not protrude past the image borders
    valid = valid and x+w <= image_shape[0]
    valid = valid and y+h <= image_shape[1]
    return valid

# %% Extract imag patches given by a list of bounding boxes
def getImageTiles(image, boundingBoxes):
    """Cut out a collection of image tiles given by a list of bounding boxes

    Parameters
    ----------
    image : image tensor
        the image to cut tiles from
    boundingBoxes : list
        a list of 4-tuple (x,y,w,h) bounding boxes

    Returns
    -------
    list
        a list of image tensors showing the specified regions
    """
    tiles = [] # construct list of image tensors
    for bb in boundingBoxes:
        #print('cropping {}'.format(bb))
        # check if we can just crop out the bb from the image
        if bb_lies_in_image_region(image.shape, bb):
            tiles.append(tf.image.crop_to_bounding_box(image, bb[0], bb[1], bb[2], bb[3]))
        else:
            #TODO implement periodic borders
            print('{} violates image borders {}'.format(bb, image.shape))
    return tiles

def showTiles(tiles):
    """Plot a list of image tensors

    Parameters
    ----------
    tiles : list
        a list of tensors to plot
    """
    n = len(tiles)
    fig, ax = plt.subplots(n, sharex=True, figsize=(8,16))
    for i in range(n):
        ax[i].imshow(tiles[i])



# %%
def extendImageToBB(image, boundingBox):
    """Generates an image that is extended to fill a bounding box by mirroring at its sides

    Parameters
    ----------
    image : image tensor
        the image to be extended
    boundingBox : tuple
        4-tuple (x,y,w,h) bounding box in image coordinates.

    Returns
    -------
    image tensor
        the specified region where missing information was filled in by mirroring the image
    """
    # Compute the how much padding has to be generated
    (x,y,w,h) = boundingBox
    (w_img, h_img, c) = image.shape
    # x direction
    x_prepend = np.max([0, -x]) # If x<0 prepend |x| pixels
    x_append = np.max([0,x+w-w_img]) # If x+w > w_img append the difference
    # y direction
    y_prepend = np.max([0, -y])
    y_append = np.max([0,y+h-h_img])
    # Use tensorflow padding operation with 'REFLECT' option
    image_extended = tf.pad(image, paddings=[[x_prepend,x_append], # x dimension
                                             [y_prepend,y_append], # y dimension
                                             [0,0]], # channel dimension (unaltered)
                            mode='REFLECT') 
    return image_extended

# %%
def getRegionBoundary(bounding_boxes):
    """Compute the smallest bounding box that contains all bounding boxes in a list

    Parameters
    ----------
    bounding_boxes : list
        list of 4-tuple (x,y,w,h) bounding boxes

    Returns
    -------
    tuple
        4-tuple (x,y,w,h) bounding box 
    """
    n = len(bounding_boxes)
    assert n>=1, 'empty list'
    x_min, y_min, x_max, y_max = (0,0,0,0)
    for bb in bounding_boxes:
        (x,y,w,h) = bb
        x_min = np.min([x_min,x]) # topmost corner
        y_min = np.min([y_min,y]) # leftmost corner
        x_max = np.max([x_max,x+w]) # max bottom
        y_max = np.max([y_max,y+h]) # max right
    w_max = x_max - x_min # extension in x
    h_max = y_max - y_min # extension in y
    return (x_min,y_min,w_max,h_max) # (x,y,w,h)


# %% 

def getMirroredTiles(image, boundingBoxes):
    """Crop out a collection of bounding boxes from an image. If the bounding boxes extend past the image, mirror it at it's borders to fill in the missing values

    Parameters
    ----------
    image : image tensor
        the image to be cropped
    boundingBoxes : list
        a list of 4-tuple (x,y,w,h) bounding boxes that can extend past the image borders but not more than the image dimension

    Returns
    -------
    list
        a list of image tiles
    """
    # Step1 get the region covered by the bounding boxes
    region = getRegionBoundary(boundingBoxes)
    # Step2 extend the image to fit the required region
    image_extended = extendImageToBB(image, region)
    # Step3 shift all bounding boxes to account for the extension at the top left corner (new origo)
    shift_x = np.max([0,-region[0]]) # prepended pixels x
    shift_y = np.max([0,-region[1]]) # prepended pixels y
    bb_adjusted = [(x+shift_x, y+shift_y, w, h) for (x,y,w,h) in boundingBoxes]
    # Step3 cut out the tiles
    tiles = getImageTiles(image_extended,bb_adjusted)
    
    return tiles

#TODO convert list of image tensors to a batched numpy array
def listToBatch(imageList):
    image_shape  = imageList[0].shape
    n = len(imageList)
    batch = np.zeros((n,)+image_shape)
    for i, image in enumerate(imageList):
        batch[i] = image.to_numpy()
    return batch

def assembleTiles(tiles, boundingBoxes):
    """Assemble a list of tiles using the coordinates of a list of bounding boxes

    Parameters
    ----------
    tiles : list
        list of image tensors
    boundingBoxes : list
        list of nonoverlapping 4-tuple (x,y,w,h) bounding boxes in a common coordinate system used to place each tile

    Returns
    -------
    image tensor
        the assembled image
    """
    # Step 1 Determine the image region and allocate a suitable image tensor
    (x_min,y_min,w_max,h_max) = getRegionBoundary(boundingBoxes) # w,h give image size
    channels = tiles[0].shape[-1] # preserve the number of channels (assumed to be last dimenion in tensor)
    image = np.zeros((w_max,h_max,)+(channels,))
    # write tiles to the correct location in the image coordinate system (x,y) of region is origo / (0,0) in image
    for tile, bb in zip(tiles, boundingBoxes):
        (x,y,w,h) = bb # extract bounding box
        (x,y,w,h) = (x-x_min,y-y_min,w,h) # shift to image coordinates
        image[x:x+w,y:y+h,:] = tile # write tile to image
    return image

def centralCrop(image, image_size):
    """Crops out the central region as specified by image_size. The same number of pixels must be removed on each side

    Parameters
    ----------
    image : image tensor
        the image to crop
    image_size : tuple
        the dimensions of the output image

    Returns
    -------
    image tensor
        the croped image
    """
    given_size = image.shape
    assert (given_size[0]-image_size[0])%2==0, 'cannot center crop region in x direction'
    assert (given_size[1]-image_size[1])%2==0, 'cannot center crop region in x direction'
    dx = (given_size[0]-image_size[0])//2
    dy = (given_size[1]-image_size[1])//2
    image = tf.image.crop_to_bounding_box(image, dx, dy, given_size[0]-2*dx, given_size[1]-2*dy)
    return image

def cropToBB(image, boundingBox):
    return tf.image.crop_to_bounding_box(image, boundingBox[0], boundingBox[1], boundingBox[2], boundingBox[3])

#%% Tests
"""
test_image = tf.keras.preprocessing.image.load_img('../images/Abyssinian_4.jpg')
test_image = tf.keras.preprocessing.image.img_to_array(test_image)/255
aabb = rectangularTiling(test_image.shape,(100,200))
showTiling(test_image,aabb)

# %% Experiment to find out alignment of graphical and plot coordinate system
test_image = tf.keras.preprocessing.image.load_img('../images/Abyssinian_1.jpg')
test_image = tf.keras.preprocessing.image.img_to_array(test_image)/255
test_image[10:20,50:200,:] = np.zeros((10,150,3))
plt.imshow(test_image)
bb = (50,100,10,200)
bb_adj = image_to_plot(bb)
plt.gca().add_patch(plt.Rectangle(bb[0:2],bb[2],bb[3], color='blue'))
plt.gca().add_patch(plt.Rectangle(bb_adj[0:2],bb_adj[2],bb_adj[3], color='red'))
plt.xlabel('x Axis')
plt.ylabel('y Axis')
plt.text(10, 360, 'Black rect: (10,50,10,150) in image coords\nBlue rect: (50,100,10,200) in plot coords\nRed rect: (50,100,10,200) transposed to image coords')
plt.title('Coordinate systems in plt.imshow()')
plt.savefig('Coordinate Systems.png')

# %% Test Unet tiling

regions = tileUnet(test_image.shape, (110,110), (100,100))
showTiling(test_image,regions['output_boxes'])
showTiling(test_image,regions['input_boxes'])

# %% Test getImageTiles
inputTiles = getImageTiles(test_image, regions['input_boxes'])
outputTiles = getImageTiles(test_image, regions['output_boxes'])
showTiles(inputTiles)
showTiles(outputTiles)

# %% Test getRegionBoundary on a list of input boxes overlapping the test image
getRegionBoundary(regions['input_boxes'])

# %%
regions = tileUnet(test_image.shape, (300,400), (250,350))
showTiling(test_image, regions['output_boxes'])
showTiling(test_image, regions['input_boxes'])
inputTiles = getMirroredTiles(test_image,regions['input_boxes'])
showTiles(inputTiles)

# %%
showTiling(test_image, regions['output_boxes'])
image_reassembled = assembleTiles(inputTiles, regions['input_boxes'])
image_reassembled_cropped = cropToBB(image_reassembled, (regions['offset'][0],regions['offset'][1], test_image.shape[0], test_image.shape[1]))
showTiling(image_reassembled, regions['input_boxes'])
showTiling(image_reassembled_cropped, regions['output_boxes'])

# %%
"""